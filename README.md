# MultSupabase: Multi-Instance Supabase with Docker for VPS 

This project provides a script to facilitate the creation and management of multiple self-hosted Supabase instances using Docker on a single VPS. Each instance is configured with its own ports, volumes, and secrets, allowing for complete isolation. 

## Prerequisites

Before you begin, ensure you have the following software installed on your server:

1.  **Docker Engine:** [Docker Installation Instructions](https://docs.docker.com/engine/install/)
2.  **Docker Compose (Plugin):** Usually included with recent Docker Engine installations. Verify with `docker compose version`.
3.  **`bash`:** The script is written in Bash.
4.  **`openssl`:** Used for generating random secrets and passwords.
5.  **`envsubst`:** Part of the `gettext` package, used for substituting environment variables in template files. (e.g., `sudo apt-get install gettext` on Debian/Ubuntu).
6.  **`shuf`:** Part of `coreutils`, used for randomizing ports. (Usually already installed).
7.  **`git`:** To clone this repository.

## Initial Setup

1.  **Clone the Repository:**
   
    ```bash
    git clone https://github.com/KleberKarpov/multsupabase.git
    cd multsupabase
    ```

2.  **Review Templates:**
    *   **`.env.template`**: This file is the template for each Supabase instance's environment variables. Review it and adjust any default values you wish. **Important:** This file should not contain actual secrets, only placeholders like `${POSTGRES_PASSWORD}`, `${JWT_SECRET}`, etc., or safe default values.
    *   **`docker-compose.yml`**: This is the Docker Compose template. It's already configured to use environment variables for ports and volume names. Review it if you have specific Supabase customizations.
    *   **`volumes/api/kong.yml` (template, optional)**: If you use a custom base configuration for Kong that is processed with `envsubst`.
    *   **`volumes/logs/vector.yml` (template, optional)**: If you have a base configuration file for Vector.
    *   **`volumes/db/init/` (optional)**: Add any SQL scripts (`.sql`, `.sh`) to this directory that you want to run on the creation of each new database. These are generally safe to publish as they define structure, not sensitive data.

3.  **Adjust Default Host (Optional):**
    In the `generate.bash` script, you can change the `DEFAULT_HOST_BASE` variable to your most common hostname if desired:
    
    ```bash
    # Inside generate.bash
    DEFAULT_HOST_BASE="supabase.yourdomain.com"
    ```

4.  **Script Permissions:**
    Make the generation script executable:
    
    ```bash
    chmod +x generate.bash
    ```

5.  **Firewall Configuration:**
    The script generates random ports for each Supabase service to avoid conflicts. You will need to ensure that the port ranges used are open in your server's firewall (both your cloud provider's firewall, like Hetzner Cloud Firewall, and the local firewall, like `ufw` or `firewalld`).

    The default port ranges generated by the script are (check the script for exact values):
    *   PostgreSQL (external): `5410-5499`
    *   Kong HTTP: `8010-8099`
    *   Kong HTTPS: `8410-8499`
    *   Supabase Studio: `3010-3099`
    *   Auth (GoTrue): `9910-9999`
    *   REST (PostgREST): `3110-3199`
    *   Realtime: `4010-4099`
    *   Storage: `5010-5099`
    *   Imgproxy: `5110-5199`
    *   Meta (Functions, etc.): `8110-8199`
    *   Analytics: `4110-4199`

    Example for `ufw` (Ubuntu):
    
    ```bash
    sudo ufw allow 8410:8499/tcp # Kong HTTPS
    sudo ufw allow 3010:3099/tcp # Studio
    # Add other ranges as needed
    sudo ufw reload
    ```
    Consult your cloud provider's and OS documentation to configure the firewall correctly.

6.  **DNS Configuration:**

    For your Supabase instances to be accessible via a human-readable domain name (e.g., `api.myproject.com` or `supabase.yourdomain.com`), you need to configure your Domain Name System (DNS) records. This typically involves adding an **A record** (or **AAAA record** for IPv6) that points your chosen hostname to the public IP address of the server where your Supabase instances are running.

    *   **What to do:**
        1.  Identify the **public IP address** of your server (e.g., your Hetzner Cloud server IP).
        2.  Go to your DNS provider's control panel (this is where you manage your domain, like GoDaddy, Namecheap, Cloudflare, or Hetzner's DNS Console if you use them for DNS).
        3.  Create a new **A record**:
            *   **Host/Name:** This is the subdomain part.
                *   If you plan to use a general hostname like `supabase.yourdomain.com` for all instances (differentiated by port), you'd set the host to `supabase`.
                *   If you plan to use unique subdomains per instance (e.g., `instance1.yourdomain.com`, which would require a reverse proxy setup not covered by this script directly), you'd set the host to `instance1`. For this script's default behavior (access via port), a single A record for the base hostname passed to the script is sufficient.
                *   If you're using a wildcard (e.g., `*.supabase.yourdomain.com` to point all subdomains of `supabase.yourdomain.com` to your server), you might use `*` or `*.supabase` depending on your provider, but this is usually for more advanced reverse proxy setups. For now, focus on a specific A record.
            *   **Value/Points to:** Enter the **public IP address** of your server.
            *   **TTL (Time To Live):** You can usually leave this at the default (e.g., 1 hour or 3600 seconds).

    *   **Example:**
        If your server's public IP is `123.45.67.89` and you want to use `supabase.mydomain.com` as the `[base_hostname]` argument for the script, you would create an A record:
        *   Host: `supabase`
        *   Type: `A`
        *   Value: `123.45.67.89`

    *   **Propagation:** DNS changes can take some time to propagate across the internet (from a few minutes to several hours, though usually it's quick). You can use tools like `ping supabase.mydomain.com` or `nslookup supabase.mydomain.com` from your local machine to check if the domain resolves to the correct IP address after some time.

    **Important for this Script:** The `[base_hostname]` argument you provide to `generate.bash` (e.g., `supabase.yourdomain.com`) *must* resolve to your server's IP. The script then constructs URLs like `https://supabase.yourdomain.com:PORT_NUMBER`.

## How to Use

### Generate a New Supabase Instance

To generate a new instance, run the `generate.bash` script, providing a unique name for the instance and, optionally, a base hostname.

**Syntax:**

```bash
./generate.bash <instance_name> [base_hostname]
```

<instance_name>: A unique name for this instance (e.g., projectClientA, myPersonalApp). This name will be used to prefix configuration files and volumes.
[base_hostname] (Optional): The hostname that will be used to construct the API and Studio URLs. If not provided, the value of DEFAULT_HOST_BASE in the script will be used. Ensure this hostname resolves to your server's IP.

*   **Examples:
1. Generate an instance named myfirstapp using the default host defined in the script:

```bash
    ./generate.bash myfirstapp
```
2. Generate an instance named clientxyz with a specific host api.clientxyz.com:

```bash
./generate.bash clientxyz api.clientxyz.com
```

*   **The script will:**
*   `Generate unique passwords and secrets (Postgres, JWT, Anon Key, Service Role Key).`
*   `Generate non-conflicting ports for the services.`
*   `Create instance-specific configuration files (.env-instance_name, docker-compose-instance_name.yml).`
*   `Create dedicated volume directories (volumes-instance_name/).`
*   `Start the Docker containers in detached mode (-d).`
*   `At the end of the execution, the script will display important URLs, keys, and credentials generated for the new instance. Store this information securely!`

*   Generated Volume Directories Structure
For each new instance, the script creates the following directories:

```bash

volumes-instance_name/
    ├── api/
    ├── db/
    ├── functions/
    └── logs/
```

### Managing Existing Instances

Use standard Docker Compose commands, specifying the instance's compose file and environment file.

*   **View Logs:**
    ```bash
    docker compose -f docker-compose-instance_name.yml --env-file .env-instance_name logs -f
    ```
    To view logs for a specific service (e.g., `kong`):
    ```bash
    docker compose -f docker-compose-instance_name.yml --env-file .env-instance_name logs -f kong
    ```

*   **Stop an Instance:**
    ```bash
    docker compose -f docker-compose-instance_name.yml --env-file .env-instance_name down
    ```

*   **Start a Stopped Instance:**
    ```bash
    docker compose -f docker-compose-instance_name.yml --env-file .env-instance_name up -d
    ```

*   **View Container Status:**
    ```bash
    docker compose -f docker-compose-instance_name.yml --env-file .env-instance_name ps
    ```

### SMTP Settings

For email sending to work (account confirmation, password resets), you will need to configure the `SMTP_*` variables in the `generate.bash` script (or modify the `.env.template` so they can be set per instance if needed, though usually the SMTP server is the same). The current variables in the script are:
*   `SMTP_HOST`
*   `SMTP_PORT`
*   `SMTP_USER`
*   `SMTP_PASS`
*   `SMTP_SENDER_NAME`
*   `SMTP_ADMIN_EMAIL` (used as the sender)

Adjust these values for your SMTP provider.

## File Structure Generated per Instance

For each instance `<instance_name>`, the following files and directories are created (and should be ignored by git):

*   `.env-<instance_name>`: Instance-specific environment variables (CONTAINS SECRETS!).
*   `docker-compose-<instance_name>.yml`: Instance-specific Docker Compose file.
*   `volumes-<instance_name>/`: Directory containing the instance's persistent volumes (database data, processed configs, etc.).
    *   `volumes-<instance_name>/db/`
    *   `volumes-<instance_name>/functions/`
    *   `volumes-<instance_name>/logs/`
    *   `volumes-<instance_name>/api/`

## Contributing

Contributions are welcome! Feel free to open issues or pull requests.

## License

This project is licensed under the MIT License - see the `LICENSE` file for details.
